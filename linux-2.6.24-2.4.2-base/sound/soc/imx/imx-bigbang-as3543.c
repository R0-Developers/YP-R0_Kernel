
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/pm.h>
#include <linux/bitops.h>
#include <linux/platform_device.h>
#include <linux/i2c.h>
#include <linux/clk.h>

#include <linux/err.h>
#include <sound/driver.h>
#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <sound/soc-dapm.h>
#include <sound/initval.h>

#include <asm/arch/dma.h>
#include <asm/arch/spba.h>
#include <asm/arch/clock.h>
#include <asm/arch/mxc.h>
#include <asm/arch/gpio.h>
#include <asm/mach/irq.h>

#include "imx-ssi.h"
#include "imx-pcm.h"
#include "../codecs/as3543.h"
#include "../../../arch/arm/mach-mx37/crm_regs.h"
#include "../../../arch/arm/mach-mx37/mx37_pins.h"


/*
 * Debug
 */
#ifdef DRV_CODEC_DEBUG
#define dbg(format, arg...) \
	printk(AUDIO_NAME ": " format "\n" , ## arg)
#else
#define dbg(format, arg...) do {} while (0)
#endif
#define err(format, arg...) \
	printk(KERN_ERR AUDIO_NAME ": " format "\n" , ## arg)
#define info(format, arg...) \
	printk(KERN_INFO AUDIO_NAME ": " format "\n" , ## arg)
#define warn(format, arg...) \
	printk(KERN_WARNING AUDIO_NAME ": " format "\n" , ## arg)


#define AS3543_MASTER_MODE 	0			// SSI BCLK and LRC master
#define AS3543_USE_MCLK 	0			// SSI MCLK master

extern void gpio_activate_audio_ports(void);

static int gDefaultSamplerate;
static struct snd_soc_machine *pas3543_machine;

static struct platform_device *imx_as3543_snd_device;
const char imx_as3543_audio[32] = {	"as3543-imx-audio" };

extern const char as3543_codec[SND_SOC_CODEC_NAME_SIZE];
extern const char as3543_hifi_dai[SND_SOC_DAI_NAME_SIZE];



static void set_ssi_clk(int rate)
{
	struct clk *ssi_lp_apm_clk = NULL;
	struct clk *parent = NULL;

	switch (rate) {
		case 11025:
		case 22050:
		case 44100:
		case 88200:
			ssi_lp_apm_clk=clk_get(NULL, "ssi_lp_apm_clk");
			parent = clk_get(NULL, "ckih");
			clk_set_parent(ssi_lp_apm_clk, parent);
			clk_set_rate(ssi_lp_apm_clk, 11289600);
			break;
		case 8000:
		case 12000:
		case 16000:
		case 24000:
		case 32000:
		case 48000:
		case 96000:
			ssi_lp_apm_clk=clk_get(NULL, "ssi_lp_apm_clk");
            parent = clk_get(NULL, "lp_apm");
            clk_set_parent(ssi_lp_apm_clk, parent);
            clk_set_rate(ssi_lp_apm_clk, 12280000);
			break;
	clk_put(ssi_lp_apm_clk);
	clk_put(parent);
	}
}

struct mxc_audio_platform_data imx_as3543_platform_data =
{
	.ssi_num = 2,
	.src_port = 2,
	.ext_port = 5,
	.set_ssi_clk = &set_ssi_clk
};

int as3543_init(struct snd_soc_machine *as3543_mach)
{
	int ret = 0;

	dbg("Registering imx37_snd_device");

	as3543_mach = kzalloc(sizeof(struct snd_soc_machine), GFP_KERNEL);
	if (as3543_mach == NULL)
	{
		ret = -ENOMEM;
		goto snd_err;
	}

	imx_as3543_snd_device = platform_device_alloc(imx_as3543_audio, -1);
	if (!imx_as3543_snd_device)
	{
		ret = -ENOMEM;
		dbg("as3543_init() FAILED");
		return ret;
	}

	imx_as3543_snd_device->dev.platform_data = &imx_as3543_platform_data;
	platform_set_drvdata(imx_as3543_snd_device, &as3543_mach);

	ret = platform_device_add(imx_as3543_snd_device);
	if (ret)
		goto snd_err;

	AS3543Init();

	dbg("Exiting normally from as3543_init()");
	return ret;

      snd_err:
	platform_device_put(imx_as3543_snd_device);
	dbg("as3543_init() FAILED");
	return ret;
}
EXPORT_SYMBOL_GPL(as3543_init);

struct imx_3stack_pcm_state
{
	int lr_clk_active;
	int playback_active;
	int capture_active;
	struct clk *mclk;
};

#if AS3543_USE_MCLK
static int imx_3stack_startup(struct snd_pcm_substream *substream)
{
	struct snd_soc_pcm_link *pcm_link = substream->private_data;
	struct imx_3stack_pcm_state *state = pcm_link->private_data;

	if (!state->lr_clk_active) {
		state->mclk = clk_get(NULL, "cko1_clk");
		clk_enable(state->mclk);

		printk("%s: set clko, generated by ipg_perclk(8MHz)", __func__);
	}
	state->lr_clk_active++;

	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
		state->capture_active = 1;
	else
		state->playback_active = 1;


	return 0;
}
#else
static int imx_3stack_startup(struct snd_pcm_substream *substream)
{
	struct snd_soc_pcm_link *pcm_link = substream->private_data;
	struct snd_soc_dai *cpu_dai = pcm_link->cpu_dai;
	struct mxc_audio_platform_data *platform_data = pcm_link->machine->pdev->dev.platform_data;


	if(gDefaultSamplerate != 44100)
	{
		gDefaultSamplerate = 44100;															// aitdark.park 2009.08.14	Fixed samplerate: 44.1kbps

#if 0	// ssi_lp_apm_clk = 12.288M (24.576 / 2)

		switch (gDefaultSamplerate)
		{
			case 8000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 11);
				break;
			case 11025:
			case 12000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 7);
				break
			case 16000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 5);
				break;
			case 22050:
			case 24000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 3);
				break;
			case 32000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 2);
				break;
			case 44100:
			case 48000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 1);
				break;
			case 88200:
			case 96000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 0);
				break;
		}

#else // ssi_lp_apm_clk = 6.144M (24.576 / 2 / 2)

		switch (gDefaultSamplerate)
		{
			case 8000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 5);
				break;
			case 11025:
			case 12000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 3);
				break;
			case 16000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 2);
				break;
			case 22050:
			case 24000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 1);
				break;
			case 44100:
			case 48000:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 0);
				break;
			default:
				cpu_dai->ops->set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, 0);
				break;
		}

#endif

		if(platform_data->set_ssi_clk)
			platform_data->set_ssi_clk(gDefaultSamplerate);

		/* set the SSI system clock as input (unused) */
		cpu_dai->ops->set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0, SND_SOC_CLOCK_IN);
	}


	return TRUE;
}
#endif

static int imx_3stack_hifi_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
{
 	struct snd_soc_pcm_link *pcm_link = substream->private_data;
	struct snd_soc_dai *cpu_dai = pcm_link->cpu_dai;
	struct snd_soc_dai *codec_dai = pcm_link->codec_dai;
	struct imx_3stack_pcm_state *state = pcm_link->private_data;
	struct mxc_audio_platform_data *platform_data = pcm_link->machine->pdev->dev.platform_data;
	snd_pcm_format_t format = params_format(params);
	unsigned int rate = params_rate(params);
	unsigned int channels = params_channels(params);
	u32 dai_format;

	/* only need to do this once as capture and playback are sync */
	if (state->lr_clk_active > 1)
		return 0;

	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_SYNC;

	if (channels == 2)
		dai_format |= SND_SOC_DAIFMT_TDM;

	/* set codec DAI configuration */
	codec_dai->ops->set_fmt(codec_dai, dai_format);

	/* set cpu DAI configuration */
	cpu_dai->ops->set_fmt(cpu_dai, dai_format);

	/* set i.MX active slot mask */
	cpu_dai->ops->set_tdm_slot(cpu_dai, channels == 1 ? 0xfffffffe : 0xfffffffc, channels);


	return 0;
}

#if AS3543_USE_MCLK
static void imx_3stack_shutdown(struct snd_pcm_substream *substream)
{
	struct snd_soc_pcm_link *pcm_link = substream->private_data;
	struct snd_soc_dai *codec_dai = pcm_link->codec_dai;
	struct imx_3stack_pcm_state *state = pcm_link->private_data;

	printk("%s: codec_dai->active=%d\n", __func__, codec_dai->active);
	/* disable the PLL if there are no active Tx or Rx channels */
	if (!codec_dai->active){
		codec_dai->ops->set_pll(codec_dai, 0, 0, 0);
		clk_disable(state->mclk);
	}
	state->lr_clk_active--;

	/*
	 * We need to keep track of active streams in master mode and
	 * switch LRC source if necessary.
	 */

	 if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
	 	state->capture_active = 0;
	 else
	 	state->playback_active = 0;
}
#else
#define imx_3stack_shutdown	NULL
#endif

static struct snd_soc_ops imx_3stack_hifi_ops =
{
	.startup = imx_3stack_startup,
	.shutdown = imx_3stack_shutdown,
	.hw_params = imx_3stack_hifi_hw_params,
};

static void imx_3stack_init_dam(int ssi_port, int dai_port)
{
	/* WM1808 uses SSI1 or SSI2 via AUDMUX port dai_port for audio */

	/* reset port ssi_port & dai_port */
	DAM_PTCR(ssi_port) = 0;
	DAM_PDCR(ssi_port) = 0;
	DAM_PTCR(dai_port) = 0;
	DAM_PDCR(dai_port) = 0;

	/* set to synchronous */
	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_SYN;
	DAM_PTCR(dai_port) |= AUDMUX_PTCR_SYN;

#if AS3543_MASTER_MODE
	/* set Rx sources ssi_port <--> dai_port */
	DAM_PDCR(ssi_port) |= AUDMUX_PDCR_RXDSEL(dai_port);
	DAM_PDCR(dai_port) |= AUDMUX_PDCR_RXDSEL(ssi_port);

	/* set Tx frame direction and source  dai_port--> ssi_port output */
	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TFSDIR;
	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, dai_port);

	/* set Tx Clock direction and source dai_port--> ssi_port output */
	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TCLKDIR;
	DAM_PTCR(ssi_port) |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, dai_port);
#else
	/* set Rx sources ssi_port <--> dai_port */
	DAM_PDCR(ssi_port) |= AUDMUX_PDCR_RXDSEL(dai_port);
	DAM_PDCR(dai_port) |= AUDMUX_PDCR_RXDSEL(ssi_port);

	/* set Tx frame direction and source  ssi_port --> dai_port output */
	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TFSDIR;
	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, ssi_port);

	/* set Tx Clock direction and source ssi_port--> dai_port output */
	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TCLKDIR;
	DAM_PTCR(dai_port) |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, ssi_port);
#endif

}

static int imx_3stack_pcm_new(struct snd_soc_pcm_link *pcm_link)
{
	struct imx_3stack_pcm_state *state;
	int ret;

	state = kzalloc(sizeof(struct imx_3stack_pcm_state), GFP_KERNEL);
	if (state == NULL)
		return -ENOMEM;

	pcm_link->audio_ops = &imx_3stack_hifi_ops;
	pcm_link->private_data = state;

	ret = snd_soc_pcm_new(pcm_link, 1, 1);
	if (ret < 0) {
		err("%s: failed to create hifi pcm\n", __func__);
		kfree(state);
		return ret;
	}

	info("i.MX Bigbang AS3543 Audio Driver\n");

	return 0;
}

static int imx_3stack_pcm_free(struct snd_soc_pcm_link *pcm_link)
{
	kfree(pcm_link->private_data);
	return 0;
}

static const struct snd_soc_pcm_link_ops imx_3stack_pcm_ops = {
	.new = imx_3stack_pcm_new,
	.free = imx_3stack_pcm_free,
};

/* imx_3stack machine audio map */
static const char *audio_map[][3] = {

	{NULL, NULL, NULL},
};

#ifdef CONFIG_PM
static int imx_as3543_audio_suspend(struct platform_device *dev, pm_message_t state)
{
	int ret = 0;

	return ret;
}

static int imx_as3543_audio_resume(struct platform_device *dev)
{
	int ret = 0;

	return ret;
}

#else
#define imx_as3543_audio_suspend	NULL
#define imx_as3543_audio_resume		NULL
#endif

int mach_probe(struct snd_soc_machine *machine)
{
	struct snd_soc_codec *codec;
	struct snd_soc_pcm_link *pcm_link;
	struct snd_soc_machine **as3543_mach = platform_get_drvdata(machine->pdev);
	int i, ret;

	pcm_link = list_first_entry(&machine->active_list, struct snd_soc_pcm_link, active_list);

	codec = pcm_link->codec;
	codec->control_data = *as3543_mach;
	codec->ops->io_probe(codec, machine);

	/* set up imx_3stack specific audio path audio map */
	for (i = 0; audio_map[i][0] != NULL; i++)
	{
		snd_soc_dapm_connect_input(machine, audio_map[i][0], audio_map[i][1], audio_map[i][2]);
	}

 	/* connect and enable all imx_3stack AS3543 jacks (for now) */
	snd_soc_dapm_set_policy(machine, SND_SOC_DAPM_POLICY_STREAM);
	snd_soc_dapm_sync_endpoints(machine);


	/* register card with ALSA upper layers */
	ret = snd_soc_register_card(machine);
	if (ret < 0)
	{
		err("%s: failed to register sound card\n", __FUNCTION__);
		snd_soc_machine_free(machine);
		return ret;
	}

	return 0;
}

struct snd_soc_machine_ops machine_ops =
{
	.mach_probe = mach_probe,
};

static int __devinit imx_as3543_audio_probe(struct platform_device *pdev)
{
	struct snd_soc_machine **machine = platform_get_drvdata(pdev);
	struct snd_soc_pcm_link *hifi;
	struct mxc_audio_platform_data *tmp;
	int ret, hp_status;

	dbg("%s: pdev->name=%s, machine->pcm_links=%d", __func__, pdev->name, (*machine)->pcm_links);

	(*machine)->owner = THIS_MODULE;
	(*machine)->pdev = pdev;
	(*machine)->name = "Bigbang";
	(*machine)->longname = "AS3543";
	(*machine)->ops = &machine_ops;

	/* register card */
	ret = snd_soc_new_card(*machine, 1, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
	if (ret < 0)
	{
		err("%s: failed to create pcms\n", __func__);
		return ret;
	}

	/* AS3543 hifi interface */
	ret = -ENODEV;
	tmp = pdev->dev.platform_data;

	if (tmp->src_port == 2)
	{
		hifi = snd_soc_pcm_link_new(*machine, "imx_3stack-hifi",
					    &imx_3stack_pcm_ops, imx_pcm,
					    as3543_codec, as3543_hifi_dai,
					    imx_ssi_3);
	}
	else
	{
		hifi = snd_soc_pcm_link_new(*machine, "imx_3stack-hifi",
					    &imx_3stack_pcm_ops, imx_pcm,
					    as3543_codec, as3543_hifi_dai,
					    imx_ssi_1);
	}

	if (hifi == NULL)
	{
		dbg("failed to create HiFi PCM link");
		snd_soc_machine_free(*machine);
		return ret;
	}

	ret = snd_soc_pcm_link_attach(hifi);
	if (ret < 0)
	{
		dbg("%s: failed to attach hifi pcm", __func__);
		snd_soc_machine_free(*machine);
		return ret;
	}

	gpio_activate_audio_ports();

	imx_3stack_init_dam(tmp->src_port, tmp->ext_port);

	return ret;

}

static int __devexit imx_as3543_audio_remove(struct platform_device *pdev)
{
	struct snd_soc_machine **machine = platform_get_drvdata(pdev);
	struct snd_soc_codec *codec;
	struct snd_soc_pcm_link *pcm_link;

	pcm_link = list_first_entry(&(*machine)->active_list, struct snd_soc_pcm_link, active_list);

	codec = pcm_link->codec;
	codec->ops->io_remove(codec, *machine);

	snd_soc_machine_free(*machine);
	return 0;
}

static struct platform_driver imx_as3543_audio_driver =
{
	.probe 		= imx_as3543_audio_probe,
	.remove 	= __devexit_p(imx_as3543_audio_remove),
	.suspend 	= imx_as3543_audio_suspend,
	.resume 	= imx_as3543_audio_resume,
	.driver 	= {
		   			.name = imx_as3543_audio,
			   	  },
};

static int __init imx_3stack_as3543_audio_init(void)
{
	int iRet;

	iRet = platform_driver_register(&imx_as3543_audio_driver);

	if(!iRet)
		as3543_init(pas3543_machine);

	return iRet;
}

static void __exit imx_3stack_as3543_audio_exit(void)
{
	if(pas3543_machine != NULL)
		kfree(pas3543_machine);

	platform_driver_unregister(&imx_as3543_audio_driver);
}

module_init(imx_3stack_as3543_audio_init);
module_exit(imx_3stack_as3543_audio_exit);

MODULE_AUTHOR("aitdark.park");
MODULE_DESCRIPTION("AS3543 Driver for i.MX");
MODULE_LICENSE("GPL");

